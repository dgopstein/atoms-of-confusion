Sometimes the purpose of a variable changes over time... v starts as the number of arguments, but then gets assigned the value of fread later.

Simlarly what if there are 3 different ints, and they rotate values throughout the program
a=b,b=c,c=a
// some stuff
a=b,b=c,c=a

Can we use contractual obligations in our simplifications? What if they're guaranteed by a spec? E.G. argc is guaranteed to be non-negative, though there's no reason a bug, for example, couldn't invalidate that promise. (On the otherhand, whatabout something like malloc? We often assume it never returns 0, though theoretically it could) I think probably we shouldn't take advantage of these semantic constraints, but sometimes we have to in order to deobfuscate.

There are cases where the author does things by (bit) arithmetic that should have names (or library funcations), i.e. testing even/odd (x&1) or absolute value ((x<0)?-x:x)

Too many operations per statement. Can't keep track of them all. Cognitive load.

Which direction does the comma operator work, left-to-right or right-to-left?

Atoms:
*= vs =* => *a*=1;
!! as clomp to 0/1
random stuff in for loop initialization

Notes:
fread(dest, size, count, stream), returns number bytes read
in main(argc, argv), argc is guaranteed non-negative
The first for-loop does: read the nth byte of stdin into the first character of X, where n is the number of arguments to the program (or 5, if there are more than 5 arguments). Store 1 into v* and t if stdin has atleast n bytes.

Transformations:
010: add curly braces around first for-loop
020: move for-loop assignment of i to outside the loop
030: change for-loop with only condition to while
040: add parens and indentation to second for-loop
050: isolate for-loop initialization
060: indent/paranthesize ternaries
070: convert side-effect-only ternaries to if-else
080: replace commas with semi-colons
090: replace ^(xor) with !(not)
100: remove unused variables
110: convert ternary to if
