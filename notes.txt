Sometimes the purpose of a variable changes over time... v starts as the number of arguments, but then gets assigned the value of fread later.

Can we use contractual obligations in our simplifications? What if they're guaranteed by a spec? E.G. argc is guaranteed to be non-negative, though there's no reason a bug, for example, couldn't invalidate that promise.


Atoms:
*= vs =* => *a*=1;
!! as clomp to 0/1

Notes:
fread(dest, size, count, stream), returns number bytes read
in main(argc, argv), argc is guaranteed non-negative
The first for-loop does: read the nth byte of stdin into the first character of X, where n is the number of arguments to the program (or 5, if there are more than 5 arguments). Store 1 into v* and t if stdin has atleast n bytes.

